#!/usr/bin/env python3

"""
@file     pyms
@date     08/03/2022
@version  1.1.0
@license  GNU General Public License v2.0
@url      github.com/Julynx/pyms
@author   Julynx
"""

import os
import sys
import signal
import random
import contextlib
import cursor
import time
from collections import defaultdict
from pynput import keyboard
with contextlib.redirect_stdout(None):
    import pygame
import threading
import subprocess
import mutagen
from dataclasses import dataclass


@dataclass
class Bindings:
    exit = keyboard.Key.esc
    pause = keyboard.Key.pause
    volDwn = keyboard.Key.f8
    volUp = keyboard.Key.f9
    next = keyboard.Key.page_down


@dataclass
class UI:
    polling_interval = 0.5
    box_width = 46
    playIdx = 6

    box = [
        ("----", False),
        ("", True),
        ("░"*box_width, True),
        ("", True),
        ("--:-- / --:--" + " "*(box_width - 25) + "Volume: 100%", True),
        ("", True),
        ("██████    ██  ██                ██      █ ████", True),
        ("██████    ██  ██    ██████    ██████      ██  ", True),
        ("██████    ██  ██                ██      ████ █", True),
        ("", True),
        ("escape    pause       F8        F9      pg_dwn", True)
    ]

    play = ["██▄▄  ",
            "██████",
            "██▀▀  "]

    pause = ["██  ██",
             "██  ██",
             "██  ██"]


@dataclass
class Files:
    m_file = ""


# --- Signal handling functions
def exit_handler(signum, frame):
    """
    Executes whenever the signal SIGINT is received.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    pygame.mixer.music.stop()
    os.system("clear")
    cursor.show()
    os._exit(0)


def resize_handler(signum, frame):
    """
    Executes whenever the size of the terminal is changed.
    Calls redraw() in execution to update the screen.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    redraw()


# --- UI functions
def swap_symbol(symbol):
    """
    Replaces the old symbol with the new symbol passed in as argument.
    Args:
        symbol (list<str>): The new symbol.
    """
    global UI

    for i in range(len(symbol)):
        line = UI.box[UI.playIdx+i][0][0:10] + \
            symbol[i] + UI.box[UI.playIdx+i][0][16:]
        UI.box[UI.playIdx+i] = (line, True)


def redraw():
    """
    Clears the screen and redraws the ui.
    """

    global UI

    def interface(lines, box_width):
        """
        Creates a box of the terminal size, enclosing the lines
        passed in as a list of tuples.

        Args:
            lines (list): A list of tuples, each containing a line and a bool.
            The line is the text to be displayed, and the boolean is whether
            the line should be centered.

        Returns:
            str: A string of the box with the lines fitted in.
        """

        term_size = os.get_terminal_size()
        term_width = term_size.columns
        term_height = term_size.lines
        string = "\n" * (int(term_height/2) - int(len(lines)/2))
        dots = "..."

        # Limit according to terminal height
        lines = lines[:term_height-1]

        # Create the body
        for tupl in lines:
            line = tupl[0]
            line_len = len(line)

            # Shorten the line if it is too long
            if line_len > min(box_width, term_width):
                line = line[:min(box_width, term_width) - len(dots)] + dots

            if tupl[1]:
                # Center the line
                formatted_line = line.center(min(box_width, term_width))

            else:
                # Left justify the line
                formatted_line = line.ljust(min(box_width, term_width))

            # Center the final line
            formatted_line = formatted_line.center(term_width)
            string += formatted_line

        return string

    subprocess.call(['tput', 'reset'])
    cursor.hide()

    sys.stdout.flush()
    print(interface(UI.box, UI.box_width))
    sys.stdout.flush()


def update_bar():
    """
    Updates a song's progress bar calling the bar_parser function with the
    current and total seconds of the song.

    Returns:
        str: Song progress bar string.
    """
    global UI, Files

    def bar_parser(percentage, max_width):
        """
        Creates a bar of the given percentage.
        Args:
            percentage (float): The percentage of the bar to be filled.
            max_width (int): The maximum width of the bar.
        Returns:
            str: A string of the bar.
        """
        bar_width = int(percentage * max_width)
        bar = "█" * bar_width + "░" * (max_width - bar_width)

        return bar

    # Load the audio file to mutagen
    audio = mutagen.File(Files.m_file)

    # Obtain current and total times
    curr_time = int(pygame.mixer.music.get_pos() / 1000)
    total_time = max(int(audio.info.length), 1)

    # Calculate the percentage of the song that is played
    percentage = curr_time / total_time

    # Get the progress bar
    progress_bar = bar_parser(percentage, UI.box_width)
    return progress_bar


def update_song_info():
    """
    Updates a song_info string calling song_info_parser with the current
    time and total time of the song and returning the updated string.

    Returns:
        str: Song info string.
    """
    global UI, Files

    def song_info_parser(current_secs, total_secs, volume, max_width):
        """
        Parses the current time and total time of the song,
        as well as the volume centered in the line.
        Args:
            current_secs (int): The current seconds of the song.
            total_secs (int): The total seconds of the song.
            volume (float): The volume of the song.
            max_width (int): The maximum width of the line.
        Returns:
            str: A string of the song info.
        """
        # Convert the seconds to minutes and seconds
        current_mins, current_secs = divmod(current_secs, 60)
        total_mins, total_secs = divmod(total_secs, 60)

        # Convert the volume to a percentage
        volume = int(volume * 100)
        volume = volume + 1 if volume % 10 == 9 else volume

        # Format the time
        current_time = "{:02d}:{:02d}".format(current_mins, current_secs)
        total_time = "{:02d}:{:02d}".format(total_mins, total_secs)

        # Format the volume
        volume = "Volume: " + str(volume) + "%"

        # Format the final info string
        line = current_time + " / " + total_time + \
            volume.rjust(max_width - len(current_time) - len(total_time) - 3)
        return line

    # Load the audio file to mutagen
    audio = mutagen.File(Files.m_file)

    # Obtain current and total times
    curr_time = int(pygame.mixer.music.get_pos() / 1000)
    total_time = int(audio.info.length)

    # Call song_info_parser to get the song info
    song_info = song_info_parser(
        curr_time, total_time, pygame.mixer.music.get_volume(), UI.box_width)
    return song_info


def poll_interface():
    """
    Updates the progress bar and the song time info every interval.
    The thread is blocked updating the bar until the song is finished.
    """
    global UI

    while True:
        time.sleep(UI.polling_interval)

        # Update bar and song info and redraw
        UI.box[2] = (update_bar(), True)
        UI.box[4] = (update_song_info(), True)
        redraw()


# --- Filename and string functions
def strip_path_from_filename(path):
    """
    Removes the path from the filename.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The filename without the path.
    """
    if "/" in path:
        filename = path.split("/")[-1]
        return filename
    return path


def strip_filename_from_path(path):
    """
    Removes the filename from the path.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The path without the filename.
    """
    if "/" not in path:
        return os.getcwd()
    words = path.split("/")
    words = words[:-1]
    new_path = "/".join(words)
    return new_path + "/"


def random_file(path):
    """
    Returns a random file from the given path.

    Args:
        path (str): The path to the directory to search.

    Returns:
        str: A random file from the given path.
    """
    old_filename = strip_path_from_filename(path)
    stripped_path = strip_filename_from_path(path)

    # Consider only music files in the directory
    files = os.listdir(stripped_path)
    music_files = []
    for file in files:
        if file.endswith((".mp3", ".wav", ".ogg")):
            if file != old_filename:
                music_files.append(file)

    try:
        # Get a random file from the directory (dont repeat the original file)
        random_file = random.choice(music_files)
    except IndexError or ValueError:
        raise pygame.error("No music files found in the directory.")

    # Return the path to the new random file
    return os.path.join(stripped_path, random_file)


# --- Keyboard handling functions
def keyboard_listener():
    """
    Executes in a separate thread to capture pressed keys.
    Keeps that thread blocked until a key is pressed and then
    the key is captured and handled.
    """
    global UI, Files, Bindings

    press_or_release = defaultdict(lambda: 0)

    with keyboard.Events() as events:
        for event in events:

            # (Clear user input)
            print(" "*16 + "\r", end="")

            # (Check only for key presses)
            press_or_release[event.key] += 1
            if not press_or_release[event.key] % 2:
                continue

            # -- Handle key presses --
            if event.key == Bindings.exit:
                signal.raise_signal(signal.SIGINT)

            elif event.key == Bindings.pause:
                if pygame.mixer.music.get_busy():
                    pygame.mixer.music.pause()
                    swap_symbol(UI.play)
                else:
                    pygame.mixer.music.unpause()
                    swap_symbol(UI.pause)
                redraw()

            elif event.key == Bindings.volDwn:
                curr_vol = pygame.mixer.music.get_volume()
                new_vol = round(round(curr_vol, 1), 8) - 0.10000000
                pygame.mixer.music.set_volume(new_vol)

                # Update the song info and redraw
                UI.box[4] = (update_song_info(), True)
                redraw()

            elif event.key == Bindings.volUp:
                curr_vol = pygame.mixer.music.get_volume()
                new_vol = round(round(curr_vol, 1), 8) + 0.10000000
                pygame.mixer.music.set_volume(new_vol)

                # Update the song info and redraw
                UI.box[4] = (update_song_info(), True)
                redraw()

            elif event.key == Bindings.next:
                try:
                    # Get a random file, load it and play it
                    Files.m_file = random_file(Files.m_file)
                    pygame.mixer.music.load(Files.m_file)
                    pygame.mixer.music.play()

                    # Update the song title, info and bar and redraw
                    UI.box[0] = (strip_path_from_filename(Files.m_file), False)
                    UI.box[2] = (update_bar(), True)
                    UI.box[4] = (update_song_info(), True)
                    swap_symbol(UI.pause)
                    redraw()

                except pygame.error:
                    # Rewind the current song if no random file is found
                    pygame.mixer.music.rewind()
                    if not pygame.mixer.music.get_busy():
                        pygame.mixer.music.unpause()

                        # Update the song info and bar and redraw
                        UI.box[2] = (update_bar(), True)
                        UI.box[4] = (update_song_info(), True)
                        swap_symbol(UI.pause)
                        redraw()


# --- Other functions
def infinite_queue(event_type):
    """
    Captures a song end event and adds a new song to the queue.
    The new song is randomly selected from the directory and played.
    The thread is blocked waiting for the song to end and only then
    it unblocks and plays the next song so run all the threads
    you would like to run before calling this function on the main thread.
    Args:
        event (pygame.event): The event that is captured. Usually MUSIC_END
    """
    global UI, Files

    while True:

        # When the song ends, play a new random song
        event = pygame.event.wait()
        if event.type == event_type:
            try:

                # Get a random file, load it and play it
                Files.m_file = random_file(Files.m_file)
                pygame.mixer.music.load(Files.m_file)
                pygame.mixer.music.play()

                # Update title, bar and song info and redraw
                UI.box[0] = (strip_path_from_filename(Files.m_file), False)
                UI.box[2] = (update_bar(), True)
                UI.box[4] = (update_song_info(), True)
                swap_symbol(UI.pause)
                redraw()

            except pygame.error:
                pass


# --- Main function
def main():

    global UI, Files

    # Check input arguments
    if len(sys.argv) != 2:
        print("Usage: pyms <file>")
        exit(1)
    Files.m_file = sys.argv[1]

    # If the path is a folder, get a random file from it
    if os.path.isdir(Files.m_file):
        try:
            Files.m_file = Files.m_file + \
                "/" if Files.m_file[-1] != "/" else Files.m_file
            Files.m_file = random_file(Files.m_file)
        except pygame.error:
            print("No music files found in the directory.")
            exit(1)

    # Initialize pygame mixer
    pygame.init()
    try:
        pygame.mixer.music.load(Files.m_file)
        pygame.mixer.music.play()
    except pygame.error:
        print("Error: Could not load music file.")
        sys.exit(1)

    # Send an event when the song ends
    MUSIC_END = pygame.USEREVENT+1
    pygame.mixer.music.set_endevent(MUSIC_END)

    # Fancy interface magic
    UI.box[0] = (strip_path_from_filename(Files.m_file), False)
    redraw()
    signal.signal(signal.SIGWINCH, resize_handler)
    signal.signal(signal.SIGINT, exit_handler)

    # THRD1 - Initialize the keyboard listener
    th = threading.Thread(target=keyboard_listener)
    th.start()

    # THRD2 - Initialize the infinite queue
    th2 = threading.Thread(target=infinite_queue, args=(MUSIC_END,))
    th2.start()

    # MAIN - Dynamic progress bar
    poll_interface()


if __name__ == "__main__":
    main()
