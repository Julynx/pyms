#!/usr/bin/env python3
"""
pyms: A simple terminal based music player.
"""

import os
from re import T
import sys
import signal
import random
import contextlib
import cursor
import time
from collections import defaultdict
from pynput import keyboard
with contextlib.redirect_stdout(None):
    import pygame

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
center = True

i_lines = [
    ("", True),
    ("██████    ██  ██                ██      █ ████", True),
    ("██████    ██  ██    ██████    ██████      ██  ", True),
    ("██████    ██  ██                ██      ████ █", True),
    ("", True),
    ("escape    pause       F8        F9      pag_up", True)
]

play1 = "██▄▄  "  # i_lines[2][0][10:16]
play2 = "██████"  # i_lines[3][0][10:16]
play3 = "██▀▀  "  # i_lines[4][0][10:16]

paus1 = "██  ██"
paus2 = "██  ██"
paus3 = "██  ██"

box_width = len(i_lines[1][0])


def pause_symbol():
    """
    Replaces the play symbol with the pause symbol.
    """
    line1 = i_lines[2][0][0:10] + paus1 + i_lines[2][0][16:]
    line2 = i_lines[3][0][0:10] + paus2 + i_lines[3][0][16:]
    line3 = i_lines[4][0][0:10] + paus3 + i_lines[4][0][16:]

    i_lines[2] = (line1, True)
    i_lines[3] = (line2, True)
    i_lines[4] = (line3, True)


def play_symbol():
    """
    Replaces the pause symbol with the play symbol.
    """
    line1 = i_lines[2][0][0:10] + play1 + i_lines[2][0][16:]
    line2 = i_lines[3][0][0:10] + play2 + i_lines[3][0][16:]
    line3 = i_lines[4][0][0:10] + play3 + i_lines[4][0][16:]

    i_lines[2] = (line1, True)
    i_lines[3] = (line2, True)
    i_lines[4] = (line3, True)


def redraw():
    """
    Clears the screen and redraws the ui.
    """
    os.system("clear")
    print(boxer(i_lines))


def resize_handler(signum, frame):
    """
    Executes whenever the size of the terminal is changed.
    Calls redraw() in execution to update the screen.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    redraw()


def strip_path_from_filename(path):
    """
    Removes the path from the filename.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The filename without the path.
    """
    if "/" in path:
        filename = path.split("/")[-1]
        return filename
    return path


def strip_filename_from_path(path):
    """
    Removes the filename from the path.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The path without the filename.
    """
    if "/" not in path:
        return os.getcwd()
    words = path.split("/")
    words = words[:-1]
    new_path = "/".join(words)
    return new_path + "/"


def random_file(path):
    """
    Returns a random file from the given path.

    Args:
        path (str): The path to the directory to search.

    Returns:
        str: A random file from the given path.
    """
    old_filename = strip_path_from_filename(path)
    stripped_path = strip_filename_from_path(path)

    files = os.listdir(stripped_path)
    random_file = files[random.randint(0, len(files)-1)]
    while random_file == old_filename:
        random_file = files[random.randint(0, len(files)-1)]

    return os.path.join(stripped_path, random_file)


def boxer(lines):
    """
    Creates a box of the terminal size, enclosing the lines
    passed in as a list of tuples.

    Args:
        lines (list): A list of tuples, each containing a line and a boolean.
        The line is the text to be displayed, and the boolean is whether
        the line should be centered.

    Returns:
        str: A string of the box with the lines fitted in.
    """
    global box_width
    string = ""
    size = os.get_terminal_size()
    width = size.columns
    height = size.lines
    term = "..."

    if center:
        print("\n" * int((height/2) - (len(lines)/2)), end="")

    # Create the body
    for tupl in lines:
        line = tupl[0]
        line_len = len(line)

        if tupl[1]:
            if line_len > min(box_width, width):
                line = line[:min(box_width, width) - len(term)] + term

            # Center the line
            formatted_line = line.center(min(box_width, width))
        else:
            if line_len > min(box_width, width):
                line = line[:min(box_width, width) - len(term)] + term
            # Left justify the line
            formatted_line = line.ljust(min(box_width, width))

        # Center the line
        formatted_line = formatted_line.center(width)
        string += formatted_line + "\n"

    return string


def main():

    global i_lines

    # Check input arguments
    if len(sys.argv) != 2:
        print("Usage: pyms <file>")
        exit(1)
    m_file = sys.argv[1]

    # Initialize pygame mixer
    pygame.init()
    try:
        pygame.mixer.music.load(sys.argv[1])
        pygame.mixer.music.play()
    except pygame.error:
        print("Error: Could not load music file.")
        sys.exit(1)

    # Fancy interface magic
    cursor.hide()
    i_lines = [(strip_path_from_filename(m_file), False)] + i_lines
    redraw()
    signal.signal(signal.SIGWINCH, resize_handler)

    # Main listener loop
    press_or_release = defaultdict(lambda: 0)
    try:
        with keyboard.Events() as events:
            for event in events:

                # Clear user input
                print(" "*16 + "\r", end="")

                # Check only for key presses
                press_or_release[event.key] += 1
                if not press_or_release[event.key] % 2:
                    continue

                # If the ESC key is pressed, exit
                if event.key == keyboard.Key.esc:
                    pygame.mixer.music.stop()
                    os.system("clear")
                    cursor.show()
                    sys.exit(0)

                # If the PAUSE key is pressed, play/pause
                elif event.key == keyboard.Key.pause:
                    if pygame.mixer.music.get_busy():
                        pygame.mixer.music.pause()
                        play_symbol()
                    else:
                        pygame.mixer.music.unpause()
                        pause_symbol()
                    redraw()

                # If the PAGE DOWN key is pressed, shuffle
                elif event.key == keyboard.Key.page_down:
                    try:
                        m_file = random_file(m_file)
                        pygame.mixer.music.load(m_file)
                        i_lines[0] = (strip_path_from_filename(m_file), False)
                        pygame.mixer.music.play()
                        pause_symbol()
                        redraw()
                    except pygame.error:
                        pass

                # If the F8 key is pressed, lower volume
                elif event.key == keyboard.Key.f8:
                    curr_vol = pygame.mixer.music.get_volume()
                    new_vol = round(round(curr_vol, 1), 8) - 0.10000000
                    pygame.mixer.music.set_volume(new_vol)

                # If the F9 key is pressed, raise volume
                elif event.key == keyboard.Key.f9:
                    curr_vol = pygame.mixer.music.get_volume()
                    new_vol = round(round(curr_vol, 1), 8) + 0.10000000
                    pygame.mixer.music.set_volume(new_vol)

    except KeyboardInterrupt:
        pygame.mixer.music.stop()
        os.system("clear")
        cursor.show()
        sys.exit(0)

    # Program exit
    pygame.mixer.music.stop()
    os.system("clear")
    cursor.show()
    sys.exit(0)


if __name__ == "__main__":
    main()
