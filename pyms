#!/usr/bin/env python3
"""
pyms: A simple terminal based music player.
"""

import os
from re import T
import sys
import signal
import random
import contextlib
import cursor
import time
from collections import defaultdict
from pynput import keyboard
with contextlib.redirect_stdout(None):
    import pygame
import threading

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"

i_lines = [
    ("", True),
    ("██████    ██  ██                ██      █ ████", True),
    ("██████    ██  ██    ██████    ██████      ██  ", True),
    ("██████    ██  ██                ██      ████ █", True),
    ("", True),
    ("escape    pause       F8        F9      pg_dwn", True)
]

play1 = "██▄▄  "  # i_lines[2][0][10:16]
play2 = "██████"  # i_lines[3][0][10:16]
play3 = "██▀▀  "  # i_lines[4][0][10:16]

paus1 = "██  ██"
paus2 = "██  ██"
paus3 = "██  ██"

box_width = len(i_lines[1][0])
m_file = ""


def exit_handler(signum, frame):
    """
    Executes whenever the signal SIGINT is received.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    exit_gracefully()


def resize_handler(signum, frame):
    """
    Executes whenever the size of the terminal is changed.
    Calls redraw() in execution to update the screen.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    redraw()


def exit_gracefully():
    """
    Executes whenever the signal SIGINT is received.

    Args:
        signum (int): The signal number.
        frame (frame): The frame.
    """
    pygame.mixer.music.stop()
    os.system("clear")
    cursor.show()
    os._exit(0)


def redraw():
    """
    Clears the screen and redraws the ui.
    """
    os.system("clear")
    print(boxer(i_lines))
    sys.stdout.flush()


def pause_symbol():
    """
    Replaces the play symbol with the pause symbol.
    """
    line1 = i_lines[2][0][0:10] + paus1 + i_lines[2][0][16:]
    line2 = i_lines[3][0][0:10] + paus2 + i_lines[3][0][16:]
    line3 = i_lines[4][0][0:10] + paus3 + i_lines[4][0][16:]

    i_lines[2] = (line1, True)
    i_lines[3] = (line2, True)
    i_lines[4] = (line3, True)


def play_symbol():
    """
    Replaces the pause symbol with the play symbol.
    """
    line1 = i_lines[2][0][0:10] + play1 + i_lines[2][0][16:]
    line2 = i_lines[3][0][0:10] + play2 + i_lines[3][0][16:]
    line3 = i_lines[4][0][0:10] + play3 + i_lines[4][0][16:]

    i_lines[2] = (line1, True)
    i_lines[3] = (line2, True)
    i_lines[4] = (line3, True)


def strip_path_from_filename(path):
    """
    Removes the path from the filename.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The filename without the path.
    """
    if "/" in path:
        filename = path.split("/")[-1]
        return filename
    return path


def strip_filename_from_path(path):
    """
    Removes the filename from the path.

    Args:
        path (str): Full path to the file.

    Returns:
        str: The path without the filename.
    """
    if "/" not in path:
        return os.getcwd()
    words = path.split("/")
    words = words[:-1]
    new_path = "/".join(words)
    return new_path + "/"


def random_file(path):
    """
    Returns a random file from the given path.

    Args:
        path (str): The path to the directory to search.

    Returns:
        str: A random file from the given path.
    """
    old_filename = strip_path_from_filename(path)
    stripped_path = strip_filename_from_path(path)

    # Consider only music files in the directory
    files = os.listdir(stripped_path)
    music_files = []
    for file in files:
        if (file.endswith(".mp3")
                or file.endswith(".wav")
                or file.endswith(".ogg")
            ) and file != old_filename:
            music_files.append(file)

    try:
        # Get a random file from the directory (do not repeat the original file)
        random_file = random.choice(music_files)
    except IndexError or ValueError:
        pygame.mixer.music.rewind()
        if not pygame.mixer.music.get_busy():
            pygame.mixer.music.unpause()
            pause_symbol()
            redraw()
        raise pygame.error("No music files found in the directory.")

    # Return the path to the new random file
    return os.path.join(stripped_path, random_file)


def boxer(lines):
    """
    Creates a box of the terminal size, enclosing the lines
    passed in as a list of tuples.

    Args:
        lines (list): A list of tuples, each containing a line and a boolean.
        The line is the text to be displayed, and the boolean is whether
        the line should be centered.

    Returns:
        str: A string of the box with the lines fitted in.
    """
    global box_width

    string = ""
    size = os.get_terminal_size()
    width = size.columns
    height = size.lines
    term = "..."

    string = string + "\n" * int((height/2) - (len(lines)/2))

    # Create the body
    for tupl in lines:
        line = tupl[0]
        line_len = len(line)

        # Shorten the line if it is too long
        if line_len > min(box_width, width):
            line = line[:min(box_width, width) - len(term)] + term

        if tupl[1]:
            # Center the line
            formatted_line = line.center(min(box_width, width))

        else:
            # Left justify the line
            formatted_line = line.ljust(min(box_width, width))

        # Center the final line
        formatted_line = formatted_line.center(width)
        string += formatted_line + "\n"

    return string


def keyboard_listener():
    """
    Executes in a separate thread to capture pressed keys.
    Keeps that thread blocked until a key is pressed and then
    the key is captured and handled.
    """
    global i_lines, m_file

    press_or_release = defaultdict(lambda: 0)

    with keyboard.Events() as events:
        for event in events:

            # (Clear user input)
            print(" "*16 + "\r", end="")

            # (Check only for key presses)
            press_or_release[event.key] += 1
            if not press_or_release[event.key] % 2:
                continue

            # If the ESC key is pressed, exit
            if event.key == keyboard.Key.esc:
                exit_gracefully()

            # If the PAUSE key is pressed, play/pause
            elif event.key == keyboard.Key.pause:
                if pygame.mixer.music.get_busy():
                    pygame.mixer.music.pause()
                    play_symbol()
                else:
                    pygame.mixer.music.unpause()
                    pause_symbol()
                redraw()

            # If the PAGE DOWN key is pressed, shuffle
            elif event.key == keyboard.Key.page_down:
                try:
                    m_file = random_file(m_file)
                    pygame.mixer.music.load(m_file)
                    i_lines[0] = (strip_path_from_filename(m_file), False)
                    pygame.mixer.music.play()
                    pause_symbol()
                    redraw()
                except pygame.error:
                    pass

            # If the F8 key is pressed, lower volume
            elif event.key == keyboard.Key.f8:
                curr_vol = pygame.mixer.music.get_volume()
                new_vol = round(round(curr_vol, 1), 8) - 0.10000000
                pygame.mixer.music.set_volume(new_vol)

            # If the F9 key is pressed, raise volume
            elif event.key == keyboard.Key.f9:
                curr_vol = pygame.mixer.music.get_volume()
                new_vol = round(round(curr_vol, 1), 8) + 0.10000000
                pygame.mixer.music.set_volume(new_vol)


def infinite_queue(event_type):
    """
    Captures a song end event and adds a new song to the queue.
    The new song is randomly selected from the directory and played.
    The thread is blocked waiting for the song to end and only then
    it unblocks and plays the next song so run all the threads 
    you would like to run before calling this function on the main thread.
    Args:
        event (pygame.event): The event that is captured. Usually MUSIC_END
    """
    global m_file

    while True:
        event = pygame.event.wait()        # Waiting is better than polling
        # for event in pygame.event.get(): # Nice way to heat your CPU!
        if event.type == event_type:
            try:
                m_file = random_file(m_file)
                pygame.mixer.music.load(m_file)
                i_lines[0] = (strip_path_from_filename(m_file), False)
                pygame.mixer.music.play()
                pause_symbol()
                redraw()
            except pygame.error:
                pass


def main():

    global i_lines, m_file

    # Check input arguments
    if len(sys.argv) != 2:
        print("Usage: pyms <file>")
        exit(1)
    m_file = sys.argv[1]

    # Initialize pygame mixer
    pygame.init()
    try:
        pygame.mixer.music.load(sys.argv[1])
        pygame.mixer.music.play()
    except pygame.error:
        print("Error: Could not load music file.")
        sys.exit(1)

    # Send an event when the song ends
    MUSIC_END = pygame.USEREVENT+1
    pygame.mixer.music.set_endevent(MUSIC_END)

    # Fancy interface magic
    cursor.hide()
    i_lines = [(strip_path_from_filename(m_file), False)] + i_lines
    redraw()
    signal.signal(signal.SIGWINCH, resize_handler)
    signal.signal(signal.SIGINT, exit_gracefully)

    # Initialize the keyboard listener
    th = threading.Thread(target=keyboard_listener)
    th.start()

    # Initialize the infinite queue
    th2 = threading.Thread(target=infinite_queue, args=(MUSIC_END,))
    th2.start()

    # Placing infinite_queue in the main thread was making resizing laggy
    # so I placed it in a separate thread. Idk why, honestly, but it works.


if __name__ == "__main__":
    main()
